#!/bin/sh
# vim: set filetype=sh:

################################################################################
# Purpose:   1. Wrap the official Bitwarden CLI utility with a helper script.
#            2. Keep Bitwarden vault login persistent between user logins.
# Args/Opts: See usage (run with -h option).
# Meta:      Script installed by ansible {{ role_name | basename }}.
# Style:     ENV_VAR, Global_Var, _Global_Readonly_Var, func_local_var
################################################################################

# GLOBAL VARS:

# Hard-Coded Settings
readonly Prog_Name="$(basename "${0}")"

# User Cmd Option Selections
Print_Help_Menu='false'
Print_Entry_And_Copy_Pswd='false'
Print_Entry='false'
Copy_Entry_Pswd='false'
Lock_Vault_And_Logout='false'
Check_Login_And_Unlock='false'

# User Cmd Option Args
Srch_Text=''
Login_Api_Key_Client_Id='{{ bitwarden_cli_api_key_client_id }}'
Login_Api_Key_Client_Secret='{{ bitwarden_cli_api_key_client_secret }}'
Session_Key_Save_File_Path='/home/{{ bitwarden_user_name }}/.local/state/bitwarden/session_key.txt'

# Bitwarden CLI Cmds
readonly _Bw_Cli_Cmd='bw'
readonly _Bw_Redir_Devnull='1> /dev/null 2>&1'
readonly _Bw_Login_Check_Cmd="${_Bw_Cli_Cmd} login --check ${_Bw_Redir_Devnull}"
readonly _Bw_Unlock_Check_Cmd_Prefix="${_Bw_Cli_Cmd} unlock --check --session"
readonly _Bw_Unlock_Check_Cmd_Suffix="${_Bw_Redir_Devnull}"

# LOCAL FUNCTIONS:

print_usage() {
  printf "USAGE:\n"
  printf "  %s  -h\n" "${Prog_Name}"
  printf "  %s  [-I <id>]  [-T <sec>]  [-K <path>]     [srch_text]\n" "${Prog_Name}"
  printf "  %s  [-I <id>]  [-T <sec>]  [-K <path>]  -s [srch_text]\n" "${Prog_Name}"
  printf "  %s  [-I <id>]  [-T <sec>]  [-K <path>]  -p [srch_text]\n" "${Prog_Name}"
  printf "  %s  [-I <id>]  [-T <sec>]  [-K <path>]  -c [srch_text]\n" "${Prog_Name}"
  printf "  %s  [-I <id>]  [-T <sec>]  [-K <path>]  -x\n" "${Prog_Name}"
  printf "  %s  [-I <id>]  [-T <sec>]  [-K <path>]  -k\n" "${Prog_Name}"
  printf "ARGUMENTS:\n"
  printf "  [srch_text]\n"
  printf "      search for entry, print it, and copy password to clipboard\n"
  printf "OPTIONS:\n"
  printf "  -h, --help\n"
  printf "      print this help message\n"
  printf "  -s [srch_text], --print-entry-and-copy-pswd[=srch_text]\n"
  printf "      search for entry, print it, and copy password to clipboard\n"
  printf "  -p [srch_text], --print-entry[=srch_text]\n"
  printf "      search for entry, and print it\n"
  printf "  -c [srch_text], --copy-entry-pswd[=srch_text]\n"
  printf "      search for entry, and copy password to clipboard\n"
  printf "  -x, --lock-vault-and-logout\n"
  printf "      lock vault and logout (Note: vault remains unlocked between user logins)\n"
  printf "  -k, --check-login-and-unlock\n"
  printf "      check if logged in to vault, and if vault is unlocked\n"
  printf "  -I <id>, --login-api-key-client-id=<id>\n"
  printf "      API key client id used to log in to bitwarden (default \"%s\")\n" "${Login_Api_Key_Client_Id}"
  printf "  -T <sec>, --login-api-key-client-secret=<sec>\n"
  printf "      API key client secret used to log in to bitwarden (default \"%s\")\n" "${Login_Api_Key_Client_Secret}"
  printf "  -K <path>, --session-key-save-file-path=<path>\n"
  printf "      session key save file path, for reboot-persistence (default \"%s\")\n" "${Session_Key_Save_File_Path}"
  printf "EXIT CODES:\n"
  printf "    0  ok\n"
  printf "    1  usage, arguments, or options error\n"
  printf "    5  Bitwarden CLI operation error\n"
  printf "   10  Bitwarden CLI vault login/unlock error\n"
  printf "  255  unknown error\n"
}

get_cmd_opts() {
  while getopts ':hs:p:c:xkI:T:K:-:' option; do
    short_opt_arg="${OPTARG}"
    case "${option}" in
      h)  handle_print_help_menu ;;
      s)  handle_print_entry_and_copy_pswd "${short_opt_arg}" ;;
      p)  handle_print_entry "${short_opt_arg}" ;;
      c)  handle_copy_entry_pswd "${short_opt_arg}" ;;
      x)  handle_lock_vault_and_logout ;;
      k)  handle_check_login_and_unlock ;;
      I)  handle_login_api_key_client_id "${short_opt_arg}" ;;
      T)  handle_login_api_key_client_secret "${short_opt_arg}" ;;
      K)  handle_session_key_save_file_path "${short_opt_arg}" ;;
      -)  long_opt_name="${OPTARG}"
          long_opt_arg="${OPTARG#*=}"
          case ${long_opt_name} in
            help)                           handle_print_help_menu ;;
            help=*)                         handle_illegal_long_option_arg "${long_opt_name}" ;;
            print-entry-and-copy-pswd=?*)   handle_print_entry_and_copy_pswd "${long_opt_arg}" ;;
            print-entry-and-copy-pswd*)     handle_print_entry_and_copy_pswd ;;
            print-entry=?*)                 handle_print_entry "${long_opt_arg}" ;;
            print-entry*)                   handle_print_entry ;;
            copy-entry-pswd=?*)             handle_copy_entry_pswd "${long_opt_arg}" ;;
            copy-entry-pswd*)               handle_copy_entry_pswd ;;
            lock-vault-and-logout=?*)       handle_lock_vault_and_logout ;;
            lock-vault-and-logout*)         handle_illegal_long_option_arg "${long_opt_name}" ;;
            check-login-and-unlock=?*)      handle_check_login_and_unlock ;;
            check-login-and-unlock*)        handle_illegal_long_option_arg "${long_opt_name}" ;;
            login-api-key-client-id=?*)     handle_login_api_key_client_id "${long_opt_arg}" ;;
            login-api-key-client-id*)       handle_missing_long_option_arg "${long_opt_name}" ;;
            login-api-key-client-secret=?*) handle_login_api_key_client_secret "${long_opt_arg}" ;;
            login-api-key-client-secret*)   handle_missing_long_option_arg "${long_opt_name}" ;;
            session-key-save-file-path=?*)  handle_session_key_save_file_path "${long_opt_arg}" ;;
            session-key-save-file-path*)    handle_missing_long_option_arg "${long_opt_name}" ;;
            '')                             break ;; # non-option arg starting with '-'
            *)                              handle_unknown_option "${long_opt_name}" ;;
          esac ;;
      \?) handle_unknown_option "${short_opt_arg}" ;;
    esac
  done
}

get_cmd_args() {
  shift $((OPTIND - 1))
  possible_cmd_arg="${1}"

  if [ "${possible_cmd_arg}" != '' ]; then
    if [ "${Srch_Text}" = '' ]; then
      Srch_Text="${1}"
    else
      err_msg="don't specify srch_text as both option arg and cmd arg"
      quit_err_msg_with_help "${err_msg}" 1
    fi
  fi
}

print_err_msg() {
  err_msg="${1}"
  printf "ERROR:\n%s: %s\n" "${Prog_Name}" "${err_msg}"
}

quit_err_msg() {
  err_msg="${1}"
  err_code="${2}"
  print_err_msg "${err_msg}"
  exit "${err_code}"
}

quit_err_msg_with_help() {
  err_msg="${1}"
  err_code="${2}"
  print_err_msg "${err_msg}"
  printf "\n"
  print_usage
  exit "${err_code}"
}

handle_unknown_option() {
  short_opt_letter_or_long_opt_name="${1}"
  err_msg="unknown option \"${short_opt_letter_or_long_opt_name}\""
  quit_err_msg_with_help "${err_msg}" 1
}

handle_illegal_long_option_arg() {
  long_opt_name="${1}"
  err_msg="illegal argument in \"${long_opt_name}\""
  quit_err_msg_with_help "${err_msg}" 1
}

handle_missing_long_option_arg() {
  long_opt_name="${1}"
  err_msg="missing argument for option \"${long_opt_name}\""
  quit_err_msg_with_help "${err_msg}" 1
}

handle_print_help_menu() {
  if [ "${Print_Entry_And_Copy_Pswd}" = 'true' ] || \
     [ "${Print_Entry}" = 'true' ] || \
     [ "${Copy_Entry_Pswd}" = 'true' ] || \
     [ "${Lock_Vault_And_Logout}" = 'true' ] || \
     [ "${Check_Login_And_Unlock}" = 'true' ]; then
    quit_err_msg_with_help "mutually exclusive options selected" 1
  fi
  Print_Help_Menu='true'
}

handle_print_entry_and_copy_pswd() {
  if [ "${Print_Help_Menu}" = 'true' ] || \
     [ "${Print_Entry}" = 'true' ] || \
     [ "${Copy_Entry_Pswd}" = 'true' ] || \
     [ "${Lock_Vault_And_Logout}" = 'true' ] || \
     [ "${Check_Login_And_Unlock}" = 'true' ]; then
    quit_err_msg_with_help "mutually exclusive options selected" 1
  fi
  Print_Entry_And_Copy_Pswd='true'
  Srch_Text="${1}"
}

handle_print_entry() {
  if [ "${Print_Help_Menu}" = 'true' ] || \
     [ "${Print_Entry_And_Copy_Pswd}" = 'true' ] || \
     [ "${Copy_Entry_Pswd}" = 'true' ] || \
     [ "${Lock_Vault_And_Logout}" = 'true' ] || \
     [ "${Check_Login_And_Unlock}" = 'true' ]; then
    quit_err_msg_with_help "mutually exclusive options selected" 1
  fi
  Print_Entry='true'
  Srch_Text="${1}"
}

handle_copy_entry_pswd() {
  if [ "${Print_Help_Menu}" = 'true' ] || \
     [ "${Print_Entry_And_Copy_Pswd}" = 'true' ] || \
     [ "${Print_Entry}" = 'true' ] || \
     [ "${Lock_Vault_And_Logout}" = 'true' ] || \
     [ "${Check_Login_And_Unlock}" = 'true' ]; then
    quit_err_msg_with_help "mutually exclusive options selected" 1
  fi
  Copy_Entry_Pswd='true'
  Srch_Text="${1}"
}

handle_lock_vault_and_logout() {
  if [ "${Print_Help_Menu}" = 'true' ] || \
     [ "${Print_Entry_And_Copy_Pswd}" = 'true' ] || \
     [ "${Print_Entry}" = 'true' ] || \
     [ "${Copy_Entry_Pswd}" = 'true' ] || \
     [ "${Check_Login_And_Unlock}" = 'true' ]; then
    quit_err_msg_with_help "mutually exclusive options selected" 1
  fi
  Lock_Vault_And_Logout='true'
}

handle_check_login_and_unlock() {
  if [ "${Print_Help_Menu}" = 'true' ] || \
     [ "${Print_Entry_And_Copy_Pswd}" = 'true' ] || \
     [ "${Print_Entry}" = 'true' ] || \
     [ "${Copy_Entry_Pswd}" = 'true' ] || \
     [ "${Lock_Vault_And_Logout}" = 'true' ]; then
    quit_err_msg_with_help "mutually exclusive options selected" 1
  fi
  Check_Login_And_Unlock='true'
}

handle_login_api_key_client_id() {
  Login_Api_Key_Client_Id="${1}"
}

handle_login_api_key_client_secret() {
  Login_Api_Key_Client_Secret="${1}"
}

handle_session_key_save_file_path() {
  Session_Key_Save_File_Path="${1}"
}

try_with_exit() {
  cmd="${1}"
  err_msg="${2}"
  err_code="${3}"
  eval "${cmd}"
  exit_code="${?}"
  if [ "${exit_code}" != 0 ]; then
    quit_err_msg "${err_msg}" "${err_code}"
  fi
}

try_with_fallback() {
  try_cmd="${1}"
  fallback_cmd="${2}"
  err_msg="${3}"
  err_code="${4}"
  eval "${try_cmd}"
  exit_code="${?}"
  if [ "${exit_code}" != 0 ]; then
    eval "${fallback_cmd}"
    exit_code="${?}"
    if [ "${exit_code}" != 0 ]; then
      quit_err_msg "${err_msg}" "${err_code}"
    fi
  fi
}

create_session_key_save_file_as_req() {
  if [ ! -f "${Session_Key_Save_File_Path}" ]; then
    session_key_save_file_dir=$(dirname "${Session_Key_Save_File_Path}")
    mkdir -p "${session_key_save_file_dir}"
    printf "%s" 'NoSessionKeyYet' > "${Session_Key_Save_File_Path}"
  fi
}

login_to_bitwarden_as_req() {
  show_prep_msg='printf "Logging in to Bitwarden vault...\n"'
  set_api_key="BW_CLIENTID='${Login_Api_Key_Client_Id}' BW_CLIENTSECRET='${Login_Api_Key_Client_Secret}'"
  login_to_bw="${_Bw_Cli_Cmd} login --raw --apikey"
  show_stat_msg='printf "Successfully logged in.\n"'
  run_login_cmd="${show_prep_msg} && ${set_api_key} ${login_to_bw} && ${show_stat_msg}"

  try_with_fallback \
    "${_Bw_Login_Check_Cmd}" \
    "${run_login_cmd}" \
    "Bitwarden CLI error attempting to login" 10
}

unlock_bitwarden_vault_as_req() {
  session_key="$(cat "${Session_Key_Save_File_Path}")"
  run_unlock_check_cmd="${_Bw_Unlock_Check_Cmd_Prefix} \"${session_key}\" ${_Bw_Unlock_Check_Cmd_Suffix}"

  show_prep_msg='printf "Unlocking Bitwarden vault...\n"'
  unlock_bw_vault="${_Bw_Cli_Cmd} unlock --raw > \"${Session_Key_Save_File_Path}\""
  show_stat_msg='printf "Successfully unlocked vault.\n"'
  run_unlock_cmd="${show_prep_msg} && ${unlock_bw_vault} && ${show_stat_msg}"

  try_with_fallback \
    "${run_unlock_check_cmd}" \
    "${run_unlock_cmd}" \
    "Bitwarden CLI error attempting to unlock vault" 10
}

login_to_bitwarden_and_unlock_vault_as_req() {
  create_session_key_save_file_as_req "$@"
  login_to_bitwarden_as_req "$@"
  unlock_bitwarden_vault_as_req "$@"
}

do_print_help_menu() {
  print_usage
}

do_print_entry_and_copy_pswd() {
  login_to_bitwarden_and_unlock_vault_as_req "$@"
  # logins="$(bw list items --search $1)"
  # if [ $(printf "%s" "$logins" | jq ". | length") -eq 1  ]; then
  #   login="$(printf "%s" "$logins" | jq ".[0]")"
  # else
  #   name="$(printf "%s" "$logins" | jq --raw-output ".[].name" | fzf --reverse)"
  #   login="$(printf "%s" "$logins" | jq ".[] | select(.name == \"$name\")")"
  # fi
}

do_print_entry() {
  login_to_bitwarden_and_unlock_vault_as_req "$@"
}

do_copy_entry_pswd() {
  login_to_bitwarden_and_unlock_vault_as_req "$@"
}

do_lock_vault_and_logout() {
  # Note: logging out automatically locks the vault and invalidates session key
  printf "Locking Bitwarden vault and logging out...\n"
  ${_Bw_Cli_Cmd} logout 1> /dev/null 2>&1

  exit_code="${?}"
  if [ "${exit_code}" = 1 ]; then
    printf "Vault already locked, and already logged out.\n"
  elif [ "${exit_code}" != 0 ]; then
    quit_err_msg "Bitwarden CLI error attempting to logout" 5
  else
    printf "Successfully locked vault and logged out.\n"
  fi
}

do_check_login_and_unlock() {
  create_session_key_save_file_as_req "$@"

  eval "${_Bw_Login_Check_Cmd}"
  exit_code="${?}"
  if [ "${exit_code}" = 0 ]; then
    login_status="logged in"
  elif [ "${exit_code}" = 1 ]; then
    login_status="logged out"
  else
    quit_err_msg "Bitwarden CLI error attempting to check vault login" 5
  fi

  session_key="$(cat "${Session_Key_Save_File_Path}")"
  run_unlock_check_cmd="${_Bw_Unlock_Check_Cmd_Prefix} \"${session_key}\" ${_Bw_Unlock_Check_Cmd_Suffix}"
  eval "${run_unlock_check_cmd}"
  exit_code="${?}"
  if [ "${exit_code}" = 0 ]; then
    vault_status="unlocked"
  elif [ "${exit_code}" = 1 ]; then
    vault_status="locked"
  else
    quit_err_msg "Bitwarden CLI error attempting to check vault unlock" 5
  fi

  printf "Vault status: %s, %s.\n" "${login_status}" "${vault_status}"
}

# MAIN SCRIPT:

main() {
  get_cmd_opts "$@"
  get_cmd_args "$@"
  if [ "${Print_Help_Menu}" = 'true' ]; then
    do_print_help_menu "$@"
  elif [ "${Print_Entry_And_Copy_Pswd}" = 'true' ]; then
    do_print_entry_and_copy_pswd "$@"
  elif [ "${Print_Entry}" = 'true' ]; then
    do_print_entry "$@"
  elif [ "${Copy_Entry_Pswd}" = 'true' ]; then
    do_copy_entry_pswd "$@"
  elif [ "${Lock_Vault_And_Logout}" = 'true' ]; then
    do_lock_vault_and_logout "$@"
  elif [ "${Check_Login_And_Unlock}" = 'true' ]; then
    do_check_login_and_unlock "$@"
  else
    do_print_entry_and_copy_pswd "$@"
  fi
  exit 0
}

main "$@"

